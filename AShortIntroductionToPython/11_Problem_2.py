# A Short Introduction To Python
# FILE 11 - PROBLEM 2
# Adam Peterlein - Last updated 2019-01-29 with python 3.6.5 and Visual Studio 15.7.1.
# Any questions, suggestions, or comments welcome and appreciated.

euler = __import__("9_Intro_To_Euler_Problems")

# PROBLEM STATEMENT
#   Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting 
#   with 1 and 2, the first 10 terms will be 1, 2, 3, 5, 8, 13, 21, 34, 55, and 89. By considering the 
#   terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the 
#   even-valued terms.

#   First we shall attempt to solve it the niave way:
def Attempt_One():
    fib = [0, 1] # A list of all the fib numbers we've discovered so far.
    while True:
        nxt = fib[-1] + fib[-2] 
        if nxt > 4E6: # If we're over 4 million break out of the loop.
            break
        fib.append(nxt) # add this value to the list of known fib numbers.
    return sum(filter(lambda x: x % 2 == 0, fib)) # Filter non-even terms and sum.

#   This is all well and good, but lets see if we can't use a generator:
def fib(mx):
    lst, snd = 1, 0
    yield snd
    yield lst
    while True:
        nxt = lst + snd
        if nxt > mx:
            break
        yield nxt
        snd = lst
        lst = nxt
   
#   Now we need to a function to take the generator, filter odd terms, and sum
def Attempt_Two():
    return sum(filter(lambda x: x % 2 == 0, fib(4E6)))

#   Using a little math we can be sneaky. It's possible to only generate even fib numbers!
def evenFib(mx):
    c, p = 1, 1
    yield 2
    while True:
        p += 2 * c
        c = 2 * p - c
        if(p + c > mx):
            break
        yield p + c

#   Now we just need to sum! No need to filter.
def Attempt_Three():
    return sum(evenFib(4E6))

#   Let's run them all and see which is fastest!
if __name__ == "__main__":
    atmpt_1 = euler.Problem(Attempt_One, 2)
    euler.display(*atmpt_1.run())

    atmpt_2 = euler.Problem(Attempt_Two, 2)
    euler.display(*atmpt_2.run())

    atmpt_3 = euler.Problem(Attempt_Three, 2)
    euler.display(*atmpt_3.run())

#   As we suspected the final attempt takes much less time than the other two.
#   What's more interesting is that attempts 1 and 2 take almost exactly the same
#   amount of time. At least in this case, using a generator doesn't cost us anything
#   and makes the code a little prettier.

